import pandas as pd
import pyodbc
from datetime import datetime, timedelta
import os
from dotenv import load_dotenv

# ============================================================
# 1. Carregar vari√°veis de ambiente
# ============================================================
load_dotenv()

server = os.getenv('SQL_SERVER', 'MURILO\\SQLEXPRESS')
database = os.getenv('SQL_DATABASE', 'EmpresaFinanceira')

conn_str = (
    r'DRIVER={ODBC Driver 17 for SQL Server};'
    f'SERVER={server};'
    f'DATABASE={database};'
    r'Trusted_Connection=yes;'
)

conn = pyodbc.connect(conn_str)
cursor = conn.cursor()

def safe_str(value):
    if pd.notna(value):
        return str(value).strip()
    return ""

# ============================================================
# 2. Fun√ß√£o robusta para converter datas
# ============================================================
def excel_serial_to_date(value):
    if pd.isna(value):
        return None

    if isinstance(value, (datetime, pd.Timestamp)):
        return value

    try:
        return datetime(1899, 12, 30) + timedelta(days=int(value))
    except:
        pass

    try:
        return pd.to_datetime(value, dayfirst=True)
    except:
        return None

# ============================================================
# 3. Fun√ß√£o para carregar Excel
# ============================================================
def load_excel(path, sheet="Sheet1"):
    print(f"\nüìÑ Carregando arquivo: {path}")

    df = pd.read_excel(path, sheet_name=sheet)
    df.columns = df.columns.str.strip().str.lower()

    print("‚úÖ Colunas encontradas:", list(df.columns))
    return df

# ============================================================
# 4. Fun√ß√£o MERGE com hash din√¢mico (essa fun√ß√£o j√° elimina duplicados)
# ============================================================
def merge_rows(df, table, columns, converters=None):

    # Criar hash dinamicamente baseado na tabela
    if "hash" not in df.columns:

        # Fluxo de Caixa
        if table.lower() == "fluxocaixa":
            df["hash"] = (
        df["data"].apply(safe_str) + "-" +
        df["tipo"].apply(safe_str) + "-" +
        df["categoria"].apply(safe_str) + "-" +
        df["centro_custo"].apply(safe_str) + "-" +
        df["forma_pagamento"].apply(safe_str) + "-" +
        df["valor"].apply(safe_str)
    )

        # Despesas
        elif table.lower() == "despesas":
            df["hash"] = (
                df["data"].astype(str) + "-" +
                df["categoria"].astype(str) + "-" +
                df["valor"].astype(str)
            )

        # Receitas
        elif table.lower() == "receitas":
            df["hash"] = (
                df["data"].astype(str) + "-" +
                df["cliente"].astype(str) + "-" +
                df["valor"].astype(str)
            )

        # Or√ßado vs Realizado
        elif table.lower() == "orcadovsrealizado":
            df["hash"] = (
                df["mes"].astype(str) + "-" +
                df["categoria"].astype(str)
            )

        else:
            raise Exception(f"N√£o sei como gerar hash para a tabela {table}.")

    # Converter colunas (datas, etc.)
    if converters:
        for col, func in converters.items():
            df[col] = df[col].apply(func)

    # MERGE SQL
    merge_sql = f"""
    MERGE {table} AS target
    USING (VALUES ({','.join(['?'] * len(columns))})) AS source ({','.join(columns)})
    ON target.hash = source.hash

    WHEN MATCHED THEN
        UPDATE SET
            {', '.join([f"{col} = source.{col}" for col in columns if col != 'hash'])}

    WHEN NOT MATCHED THEN
        INSERT ({', '.join(columns)})
        VALUES ({','.join([f"source.{col}" for col in columns])});
    """

    print(f"‚û°Ô∏è Processando MERGE na tabela {table}...")

    for _, row in df.iterrows():
        cursor.execute(merge_sql, *(row[col] for col in columns))

    conn.commit()
    print(f"‚úÖ MERGE conclu√≠do para {table}!")

# ============================================================
# 5. Processar cada arquivo
# ============================================================

# FLUXO DE CAIXA
df_fluxo = load_excel("fluxo_caixa.xlsx")
merge_rows(
    df_fluxo,
    table="FluxoCaixa",
    columns=["hash", "data", "tipo", "categoria", "centro_custo", "forma_pagamento", "valor", "saldo_acumulado"],
    converters={"data": excel_serial_to_date}
)

# DESPESAS
df_desp = load_excel("despesas.xlsx")
merge_rows(
    df_desp,
    table="Despesas",
    columns=["hash", "data", "categoria", "centro_custo", "tipo_despesa", "valor"],
    converters={"data": excel_serial_to_date}
)

# OR√áADO VS REALIZADO
df_orcado = load_excel("orcado_vs_realizado.xlsx")
merge_rows(
    df_orcado,
    table="OrcadoVsRealizado",
    columns=["hash", "mes", "categoria", "valor_orcado", "valor_realizado", "desvio_percentual"],
    converters={"mes": excel_serial_to_date}
)

# RECEITAS
df_rec = load_excel("receitas.xlsx")
merge_rows(
    df_rec,
    table="Receitas",
    columns=["hash", "data", "cliente", "produto_servico", "forma_recebimento", "valor"],
    converters={"data": excel_serial_to_date}
)

# ============================================================
# 6. Fechar conex√£o
# ============================================================
cursor.close()
conn.close()

print("\n‚úÖ Todos os dados foram processados com MERGE e est√£o atualizados no SQL Server!")